# comparator.py - A text comparation tool. Uses a dict+tsvd pair generated by generator.py
# Made with <3 by AmÃ©lia O. F. da S.
# Make good use!

import melmap
import pickle
import argparse
parser=argparse.ArgumentParser(description="A simple text comparation interface")
parser.add_argument('--tsvd',help='The compiled reference file',required=True)
parser.add_argument('--dict',help='The compiled dictionary file',required=True)
parser.add_argument('--text_comp',help='A comma-separated list of paths to the files to be compared to the reference. If none are provided, the program waits for input on stdin (until it receives an EOF signal).')
parser.add_argument('--stopwords',help='Stopwords dictionary',required=True)
parser.add_argument('-b',help='Brief output (csv)')
args=vars(parser.parse_args())

stopwords=[]
with open(args['stopwords']) as our_dictionary:
    stopwords=our_dictionary.read().split("\n")
    our_dictionary.close()

brief=True if args['b'] else False
wordset,references=([],[])
with open(args['dict'],'rb') as our_file:
    wordset=pickle.load(our_file)
with open(args['tsvd'],'rb') as our_file:
    references=pickle.load(our_file)

if args['text_comp']:
    if not brief:
        print("Comparing texts...")
    else:
        for i,reference in enumerate(references):
            print('ref'+str(i)+'_magnitude',end=',')
            print('ref'+str(i)+'_angle',end=',')
            print('ref'+str(i)+'_score',end=',')
        print('filename')
    our_files=args['text_comp']
    files=our_files.split(',')
    for findex,fil in enumerate(files):
        with open(fil) as ff:
            results=[]
            textb=ff.read()
            _,matrixb=melmap.freqMap(textb,wordset,5,stopwords,lambda w: w**2)
            if not brief:
                print('## Analysing "'+fil+'" ##')
            for reference in references:
                projection=melmap.ApplyComponent(matrixb,reference[0])
                results.append((melmap.scprod(projection,projection),melmap.vectorAngle(reference[1],projection)))
            mag_extremes=(max(results,key=lambda x:x[0])[0],min(results,key=lambda x:x[0])[0])
            ang_extremes=(max(results,key=lambda x:x[1])[1],min(results,key=lambda x:x[1])[1])
            mag_extremes=(mag_extremes[0],mag_extremes[1],mag_extremes[0]-mag_extremes[1])
            ang_extremes=(ang_extremes[0],ang_extremes[1],ang_extremes[0]-ang_extremes[1])
            results=[((result[0]-mag_extremes[1])/(mag_extremes[2]),(result[1]-ang_extremes[1])/(ang_extremes[2])) for result in results]
            results=[(result[0],result[1],(result[0]+(1-result[1]))) for result in results]
            score_extremes=(max(results,key=lambda x:x[2])[2],min(results,key=lambda x:x[2])[2])
            score_extremes=(score_extremes[0],score_extremes[1],score_extremes[0]-score_extremes[1])
            results=[(result[0],result[1],(result[2]-score_extremes[1])/(score_extremes[2])) for result in results]
            if not brief:
                for i,reference in enumerate(references):
                    print("Reference \""+reference[2]+"\":")
                    print("\tNormalized magnitude: "+str(round(results[i][0],4)))
                    print("\tNormalized angle: "+str(round(results[i][1],4)))
                    print("\tNormalized score: "+str(round(results[i][2],4)))
            else:
                for i,reference in enumerate(references):
                    print(str(results[i][0]),end=',')
                    print(str(results[i][1]),end=',')
                    print(str(results[i][2]),end=',')
                print(str(findex))
            ff.close()
    print("Done!")